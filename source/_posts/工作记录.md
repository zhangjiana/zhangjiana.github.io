---
title: 工作记录
copyright: true
date: 2021-02-25 17:24:11
tags: 日常
---

## 1. 使用iframe的时候，自动改变iframe 的高度
场景： A页面使用iframe 把B页面嵌入进去。B页面有几个tab切换，所以需要随时的更新 iframe 的高度。
方案： 使用postMessage

A页面
```javascript
    window.addEventListener('message', (event) => {
      const { data, origin } = event
      console.log(data)
      if (!origin) return
      this.height = data.height
    }, false)
```

B 页面发送message, 在需要告知A页面中ifrme的高度的时候，就触发这个方法。实时更新iframe 的高度
```javascript
    let height = document.querySelector('.mall-wrapper').clientHeight
    window.parent.postMessage({ height }, targetOrigin)
```


## 2. 使用.bablerc 配置无效，但是在webpack.config.js的babel-loader里面配置有效
原因是因为使用的babel-loader 是 7版本以上， 配置文件要使用babel.config.js


## 3. 使用postcss 插件使css3 自动添加前缀
说明： `postcss` 是一个解析css的插件
      `postcss-preset-env中` 包含 `autoprefixer`

版本号: 
`postcss-loader 4.2.0`
`autoprefixer: 9.8.6`
版本号一定要符合，不然的话，会报错。

webpack配置：
```
{
        test: /\.css$/,
        use: ["style-loader", "css-loader",
        {
          loader: "postcss-loader",
          options: {
            postcssOptions: {
              plugins: {"autoprefixer": {overrideBrowserslist: ['last 2 version', '>0.5%', 'ios 9']} }
            }
          } 
        }
      ],
```
### 注意
postcss-loader 执行顺序必须保证在 css-loader 之前，建议还是放在 less或者 sass 等预处理器之后更好。即 loader 顺序：less-loader -> postcss-loader -> css-loader -> style-loader 或者 MiniCssExtractPlugin.loader，其实 postcss-loader 放在 less-loader 之前问题也不大，平时使用的 less 里面的语法基本不会和 autoprefixer 处理产生冲突的。

## react 中的useState, 更改数组未触发视图更新

```javascript
  keyList.forEach((i) => {
      if (i.id !== item.id) {
        i.disabled = true
      }
  })
  // 原来是这样写的，没有触发视图更新
  setKeyList(keyList)

  // 改成下面这个，就可以触发视图更新了
   setKeyList([...keyList])
// 原因是：keyList 本身的存储地址并没有改变。 所以需要重新改变数组的地址，就可以了。
```

```javascript
// 表格列太多，导致加载时间过长，原因是因为前端时间处理的问题。

项目说明：
由于项目中的列是不确定的，所以后台给的接口是按照每条`key:value` 的形式给出的。
如： records: [
  {
    商品名称： 鞋子,
    尺寸： 22,
    价格： 333
  },
  {
    商品名称： 帽子,
    尺寸： 212,
    价格： 287
  },
  {
    商品名称： 裤子,
    尺寸： 12,
    价格： 111
  }
];
使用表格就需要把columns确定出来。
columns: [
  {
    title: '商品名称',
    dataIndex: '商品名称'
  },
  {
    title: '尺寸',
    dataIndex: '尺寸'
  },
  {
    title: '价格',
    dataIndex: '价格'
  },
]

dataSource: [
  {
    商品名称： 鞋子,
    尺寸： 22,
    价格： 333
  },
  {
    商品名称： 帽子,
    尺寸： 212,
    价格： 287
  },
  {
    商品名称： 裤子,
    尺寸： 12,
    价格： 111
  }
];

之前的做法：
    const map: any = {};
    let col: any[] = [];
    let dataSource: any[] = [];
    // 把每一个项都循环。
    records.forEach((item: any, index: number) => {
      dataSource[index] = { id: index };
      // 然后取key 作为columns。
      for (let k in item) {
        // 这里用了map存储已经获取的key。正是因为这个，导致了时间过长。
        if (!map[k]) {
          map[k] = item[k] || `tempTitle${k}`;
          titleMap[k] = false;
          let obj: any = {
            title: k,
            dataIndex: k || 'temp',
            width: 180,
            filterDropdownVisible: false,
            valueType: isImage(item[k])
              ? 'imageArray'
              : isHref(item[k])
              ? 'link'
              : 'text',
            // ellipsis: typeof item[k] === 'string', //  开启后，table 会加载慢
          };
          col.push(obj);
          setTitleMap({ ...titleMap, k: false });
        }
        dataSource[index][k || 'temp'] = item[k];
      }
    });
后来的做法：
// 直接用第一个项来获取所有 的columns。 因为每一项中的key 是相同的，没有必要进行遍历。
// 即便是用了map 来存储，但是仍然会消耗内存，导致时间过长。
// 优化以后， 从25秒降到了6秒。效果明显
  for (let k in records[0]) {
        let obj: any = {
          title: k,
          dataIndex: k || 'temp',
          width: 180,
          filterDropdownVisible: false,
          valueType: isImage(records[0][k])
            ? 'imageArray'
            : isHref(records[0][k])
            ? 'link'
            : 'text',
          // ellipsis: typeof item[k] === 'string', //  开启后，table 会加载慢
        };
        col.push(obj);
    }

```


更换域名：

# 下面代码中，listen 指令表明 server 块同时用于 HTTP流量。
# server_name 指令匹配包含域名 ‘www.old-name.com’ 的请求。return 指令告诉 Nginx 停止处理请求，直接返回 301 (Moved Permanently) 代码和指定的重写过的 URL 到客户端。
# $scheme 是协议（HTTP 或 HTTPS），$request_uri 是包含参数的完整的 URI。
server{
    listen         80;
    server_name www.old-name.com;
     
    # return 指令的第一个参数是响应码。第二个参数可选，可以是重定向的 URL
    # location 和 server 上下文中都可以使用 return 指令。
    return 301 $scheme://www.new-name.com$request_uri;
}
