---
title: 原型
copyright: true
date: 2022-03-04 14:22:39
tags:
---

## 什么是原型

只要创建函数，就会按照特定规则给这个函数创建一个`prototype`属性。把这个叫做原型对象，默认情况下，原型对象自动获得一个名为 `constructor` 的属性， 指向构造函数本身。

```js
function Person() {}

Person.prototype.constructor === Person // true
```

## 原型链

一个构造函数创建的时候，有一个原型`prototype`，原型有一个叫`constructor`的属性。

实例化一个构造函数，产生一个实例。这个实例的`__proto__`指向构造函数的`prototype`。 这整个链路就是原型链。

## 继承

原型链继承
```js
function SuperType () {
    this.property = true;
}
SuperType.prototype.getProperty = function () {
    console.log(this.property);
}
function SubType () {};

// 原型链继承
SubType.prototype = new SuperType();
var s1 = new SubType();
s1.getProperty(); // true
```
缺点：1. 原型中包含的引用值，会在所有实例中共享。
举个例子:
```js
function SuperType () {
    this.color = ['red', 'blue'];
}
function SubType () {};

// 原型链继承
SubType.prototype = new SuperType();
var s1 = new SubType();
s1.color.push('green');
console.log(s1); // ['red', 'blue', 'green']
var s2 = new SubType();

console.log(s2); // ['red', 'blue', 'green']
// s2 也共享了原型中的color。 但其实s2是不需要这个的。
```
2. 子类型在实例化时不能给父类型的构造函数传参。

## 盗用构造函数 继承

```js
function SuperType (name) {
    this.color = ['red', 'blue'];
    this.name = name
}
function SubType () {
    // 通过改变this 指向来继承。

    // 补缺了 原型链 的缺点2， 可以在子类构造函数中，向父类构造函数传参
    SuperType.call(this, 'kk');
};

var s1 = new SubType();
s1.color.push('green');
console.log(s1); // ['red', 'blue', 'green']
var s2 = new SubType();
// 这个优点就是补缺了原型链的两个缺点。
// 补上了 原型链的缺点1
console.log(s2); // ['red', 'blue']

```
缺点： 1. 必须在构造函数中定义方法，因此函数不能重用。每个实例都会拷贝一份父类 的构造函数中的方法和属性，所以函数无法复用（我们用`prototype`的初衷就是共享方法，使之可以复用）， 且内存占用大
      2. 子类不能访问父类原型中的方法，导致如果父类的原型中加了一个新方法，没有办法被其他实例共用。  

3. 组合继承
```js
function SuperType (name) {
    this.color = ['red', 'blue'];
    this.name = name
}
function SubType () {
    SuperType.call(this, 'kk');
};
SubType.prototype = new SuperType();

```

缺点： superType执行了两次, 生成了两份实例（子类实例将子类原型上的那份屏蔽了）

4. 寄生式组合继承
```js
function  inheritPrototype (subType, superType) {
    let prototype = superType.prototype; // 创建一个父类的副本
    prototype.contructor = subType; // 把这个副本的contructor 指向 子类本身
    subType.prototype = prototype; // 把副本赋值给子类的原型。
}

function SuperType(name) { 
 this.name = name; 
 this.colors = ["red", "blue", "green"]; 
}
SuperType.prototype.sayName = function() { 
 console.log(this.name); 
};
function SubType(name, age) {
    SuperType.call(this, name);
}
inheritPrototype(SubType, SuperType);
SubType.prototype.sayAge = function() { 
 console.log(this.age); 
};

```
堪称完美